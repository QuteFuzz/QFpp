
# META-GRAMMAR
(*
    Rules:
    - use `subroutines` node to encapsulate subroutine circuits
    - `qubit_def` rule MUST be defined in at least INTERNAL or EXTERNAL scope (defining in both is fine)
    - (qu)bit def must be defined using at least one of singular (qu)bit or register (qu)bit def
    Notes:
    - all rules have scope GLOBAL by default
    - must define a gate_op
    - must use `subroutine_compound_stmts` or `compound_stmts` accordingly. This is a requirement because the
        `compound_stmts` node is needed as a way for the mutation passes to tell statement boundaries, so it doesn't
        mutate across them
*)

# TODO: extend term constraints to allow passing subroutine op args properly in qiskit
# for now i limit all external qubit and bit defs to singular definitions

# default config
EXTENSION = ".py";
MAX_REG_SIZE = 5;
NESTED_MAX_DEPTH = 4;

qubit_def = singular_qubit_def | register_qubit_def;

bit_def = singular_bit_def | register_bit_def;


INTERNAL {
    qubit_def = singular_qubit_def | register_qubit_def;

    bit_def = singular_bit_def | register_bit_def;
}

EXTERNAL {
    qubit_def = singular_qubit_def | register_qubit_def;

    bit_def = singular_bit_def | register_bit_def;
}

# program       = imports NEWLINE subroutine_defs NEWLINE circuit NEWLINE program_footer;

program       = imports NEWLINE circuit NEWLINE program_footer;

program_footer = compiler_call;

subroutine_defs = (subroutine_circuit NEWLINE subroutine_def_footer)[UNIFORM(1, 3)];

# all subroutines have just qubit ops and no if-else statements
subroutine_body = EXTERNAL::qubit_defs EXTERNAL::bit_defs NEWLINE (qubit_op NEWLINE)+;

body = EXTERNAL::qubit_defs EXTERNAL::bit_defs NEWLINE compound_stmts;

subroutine_circuit = circuit_def_header NEWLINE subroutine_body;

compound_stmts = (compound_stmt NEWLINE)[UNIFORM(3,10)];

qubit_op = gate_op | subroutine_op;

gate_name = h
    | x
    | y
    | z
    | rz
    | rx
    | ry
    | cx
    | cy
    | cz
    | ccx;

# # TODO: figure this out
# gate_op_args = qubit_list
#     | qubit_list ", " bit_list
#     | float_list ", " qubit_list
#     ;

gate_op_args = (float_literal ", ")[NUM_FLOATS] qubit_list ("," bit)[NUM_BITS];

# TODO: think about this for qiskit, for now i've made all qubit definitions singular
# subroutine_op_arg =
#     qubit
#     | "[" qubit_list "]"
#     ;

subroutine_op_args = qubit_list;

qubit_list = qubit (", " qubit)[NUM_QUBITS - 1];

float_literal = FLOAT;

float_list = float_literal  (", " float_literal)[NUM_FLOATS - 1];

qubit =
    singular_qubit
    | register_qubit
    ;

bit_list = bit (", " bit)[NUM_BITS - 1];

bit = singular_bit
    | register_bit
    ;

if_stmt =
    'if' expression ':' NEWLINE INDENT compound_stmts DEDENT elif_stmt
    | 'if' expression ':' NEWLINE INDENT compound_stmts DEDENT (else_stmt)?;
elif_stmt =
    'elif' expression ':' NEWLINE INDENT compound_stmts DEDENT elif_stmt
    | 'elif' expression ':' NEWLINE INDENT compound_stmts DEDENT (else_stmt)?;
else_stmt =
    'else' ':' NEWLINE INDENT compound_stmts DEDENT;

# The expressions below are from https://docs.python.org/3/reference/grammar.html
# Parts have been commented out / removed / modified to remove unnecessary complexity

# EXPRESSIONS
# -----------

expression =
    disjunction;

disjunction =
    conjunction ('or' conjunction )+
    | conjunction;

conjunction =
    inversion ('and' inversion )+
    | inversion;

inversion =
    comparison;

# Comparison operators
# --------------------

comparison =
    bitwise_or compare_op_bitwise_or_pair;

compare_op_bitwise_or_pair =
    eq_bitwise_or
    | noteq_bitwise_or
    | lte_bitwise_or
    | lt_bitwise_or
    | gte_bitwise_or
    | gt_bitwise_or;

eq_bitwise_or: '==' bitwise_or;
noteq_bitwise_or: '!=' bitwise_or;
lte_bitwise_or: '<=' bitwise_or;
lt_bitwise_or: '<' bitwise_or ;
gte_bitwise_or: '>=' bitwise_or;
gt_bitwise_or: '>' bitwise_or ;


# Bitwise operators
# -----------------

bitwise_or:
    # | bitwise_or '|' bitwise_xor
    bitwise_xor;

bitwise_xor:
    # | bitwise_xor '^' bitwise_and
    bitwise_and;

bitwise_and:
    # | bitwise_and '&' shift_expr
    shift_expr;

shift_expr:
    # | shift_expr '<<' primary
    # | shift_expr '>>' primary
    primary;


# Primary elements
# ----------------

primary:
    atom;

atom: INTEGER;
