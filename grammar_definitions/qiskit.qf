# qiskit

NESTED_MAX_DEPTH = 3;


gate_name += s | sdg | t | tdg | u3 | measure;

u3 = "u";
x = "x";
y = "y";
z = "z";
cx = "cx";
ch = "ch";
cy = "cy";
cz = "cz";
rx = "rx";
ry = "ry";
rz = "rz";
ccx = "ccx";
tdg = "tdg";
t = "t";
sdg = "sdg";
h = "h";
t = "t";
s = "s";
measure = "measure";

# Redefine base program structure to fit Qiskit
program = imports NEWLINE NEWLINE parameter_defs NEWLINE subroutine_defs NEWLINE circuit NEWLINE program_footer;

parameter_defs = (parameter_def NEWLINE)*;

parameter_def = NAME " = Parameter('" NAME "')";

circuit = circuit_def_header NEWLINE body NEWLINE;

(*
    subroutines cannot contain classical bits as then it cannot be converted into a gate
    by extension, any gates like measure that need classical bits will never be generated inside a subroutine

    therefore also no control flow is allowed in a subroutine

    just qubit ops are allowed
*)

subroutine_compound_stmts = (qubit_op NEWLINE)[UNIFORM(3,10)];

subroutine_body = EXTERNAL::qubit_defs NEWLINE subroutine_compound_stmts;

body = EXTERNAL::qubit_defs EXTERNAL::bit_defs NEWLINE compound_stmts;

subroutine_def_footer = CIRCUIT_NAME " = " CIRCUIT_NAME ".to_gate()" NEWLINE;

circuit_def_header = NEWLINE CIRCUIT_NAME " = QuantumCircuit(0)";

# Redefine EXTERNAL scope for Qiskit register and circuit definitions
EXTERNAL {

    qubit_defs = (qubit_def NEWLINE)[UNIFORM(3,4)];

    bit_defs = (bit_def NEWLINE)[UNIFORM(3,4)];

    # Qiskit registers are defined by size and name, not individually
    singular_qubit_def =
        NAME " = QuantumRegister(1, '" NAME "')" NEWLINE
                        CIRCUIT_NAME ".add_register(" NAME ")";

    register_qubit_def =
        NAME " = QuantumRegister(" SIZE ", '" NAME "')" NEWLINE
                        CIRCUIT_NAME ".add_register(" NAME ")";

    singular_bit_def =
        NAME " = ClassicalRegister(1, '" NAME "')" NEWLINE
                        CIRCUIT_NAME ".add_register(" NAME ")";

    register_bit_def =
        NAME " = ClassicalRegister(" SIZE ", '" NAME "')" NEWLINE
                        CIRCUIT_NAME ".add_register(" NAME ")";
}

imports =
    "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister" NEWLINE
    "from qiskit.circuit import Parameter" NEWLINE
    "from qiskit.circuit.classical import expr" NEWLINE
    "from qiskit.circuit.library import standard_gates" NEWLINE
    swarm_testing_imports NEWLINE
    "from diff_testing.qiskit import qiskitTesting" NEWLINE
    ;

# Redefine compound_stmt and related rules
compound_stmts = (compound_stmt NEWLINE)[UNIFORM(3, 10)];

# Redefine gate_op for Qiskit syntax: circuit.gate(args)
gate_op = CIRCUIT_NAME "." gate_name "(" gate_op_args ")";

subroutine_op = CIRCUIT_NAME ".append(" subroutine ",[" subroutine_op_args "])";

subroutine_op_arg =
    qubit
    | qubit_list
    ;

# Control flow operations
while_stmt =
    'with ' CIRCUIT_NAME '.while_loop((' bit ', ' branch_condition ')):'
    NEWLINE INDENT<compound_stmts>;

for_stmt = for_range | for_iterable;

for_range = 
    NAME " = Parameter('" NAME "')" NEWLINE
    "with " CIRCUIT_NAME ".for_loop(range(" for_bound "), " NAME "):" 
    NEWLINE INDENT<compound_stmts>;

for_bound = INTEGER [UNIFORM(1, 5)];  # Always terminates!

for_iterable =
    NAME " = [" float_literal (", " float_literal)[UNIFORM(1, 4)] "]" NEWLINE
    "with " CIRCUIT_NAME ".for_loop(" NAME "):" 
    NEWLINE INDENT<compound_stmts>;

# TODO: SWITCH STMTS: more complex with switch over registers and case option tracking via some feature

# switch_stmt =
#     'with ' CIRCUIT_NAME '.switch(' bit ') as case' INDENT_LEVEL ':' NEWLINE
#     INDENT<((case_stmts NEWLINE) (default_case)?)>;

# case_stmts = 'with case' INDENT_LEVEL '(' 0 '):' NEWLINE INDENT<compound_stmts> NEWLINE LINE_INDENT<('with case' INDENT_LEVEL '(' 1 '):' NEWLINE INDENT<compound_stmts>)>;

# case_stmt =
#     'with case(' case_values '):' NEWLINE INDENT<compound_stmts>;

# case_values = INTEGER (', ' INTEGER)[UNIFORM(0,2)];

# default_case =
#     'with case(case.DEFAULT):' NEWLINE INDENT<compound_stmts>;

#TODO: implement `qreg` rule and others stuff needed for register comparison
# 1. Expressions that return a Number (Uint)
uint_expr =
    qreg
    | INTEGER
    | 'expr.bit_and(' uint_expr ', ' uint_expr ')'
    | 'expr.bit_or(' uint_expr ', ' uint_expr ')'
    | 'expr.bit_xor(' uint_expr ', ' uint_expr ')';

# 2. Expressions that return a Condition (Bool)
bool_expr =
    'expr.equal(' bit ',' ('True' | 'False') ')'
    # Comparisons turn Uints into Bools
    # | 'expr.equal(' uint_expr ', ' uint_expr ')'
    # | 'expr.not_equal(' uint_expr ', ' uint_expr ')'
    # | 'expr.less(' uint_expr ', ' uint_expr ')'
    # Logic combines Bools into Bools
    | 'expr.logic_or(' bool_expr ', ' bit ')'
    | 'expr.logic_and(' bool_expr ', ' bit ')'
    | 'expr.logic_not(' bit ')';

# Classical expressions
classical_expr = bool_expr;

# Update if_stmt to use classical_expr
if_stmt =
    'with ' CIRCUIT_NAME '.if_test(' classical_expr ') as else_' INDENT_LEVEL ':' NEWLINE INDENT<compound_stmts>
    LINE_INDENT<('with else_' INDENT_LEVEL ':' NEWLINE INDENT<compound_stmts>)?>;

# Update compound_stmt
compound_stmt =
    qubit_op
    | if_stmt
    # | while_stmt
    # | for_stmt        
    # | switch_stmt     # TODO: figure out how to label the nested cases properly
    | barrier_op
    | reset_op;

# Barriers and delays
barrier_op = CIRCUIT_NAME '.barrier([' qubit_list '])';
delay_op = CIRCUIT_NAME '.delay(' INTEGER ', ' qubit ')';
reset_op = CIRCUIT_NAME '.reset(' qubit ')';

branch_condition = 1 | 0;

singular_qubit = NAME "[0]";

register_qubit = NAME "[" INDEX "]";

singular_bit = NAME "[0]";

register_bit = NAME "[" INDEX "]";

compiler_call = "qt = qiskitTesting()" NEWLINE testing_method;

testing_method = "qt.ks_diff_test(main_circuit" COMMA circuit_id RPAREN NEWLINE;
