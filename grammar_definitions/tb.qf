
# META-GRAMMAR

# default config
extension = ".py";
MIN_NUM_QUBITS = 3;
MIN_NUM_BITS = 1;
MAX_NUM_QUBITS = 4;
MAX_NUM_BITS = 2;
MAX_NUM_SUBROUTINES = 5;
NESTED_MAX_DEPTH = 4;
WILDCARD_MAX = 10;

INTERNAL {
    qubit_def = singular_qubit_def | register_qubit_def;

    bit_def = singular_bit_def | register_bit_def;
}

EXTERNAL {
    qubit_def = singular_qubit_def | register_qubit_def;

    bit_def = singular_bit_def | register_bit_def;
}

program       = imports NEWLINE subroutine_defs NEWLINE circuit NEWLINE compiler_call;

subroutine_defs = (subroutine_circuit NEWLINE subroutine_def_footer)*;

# all subroutines have just qubit ops and no if-else statements
subroutine_body = EXTERNAL::qubit_defs NEWLINE (qubit_op NEWLINE)+;

body = EXTERNAL::qubit_defs EXTERNAL::bit_defs NEWLINE compound_stmts;

subroutine_circuit = circuit_def_header NEWLINE subroutine_body;

compound_stmts = (compound_stmt NEWLINE)+;

qubit_op = gate_op | subroutine_op;

gate_name = h
    | x
    | y
    | z
    | rz
    | rx
    | ry
    | cx
    | cy
    | cz
    | ccx;


gate_op_args = qubit_list
    | qubit_list ", " bit_list
    | float_list ", " qubit_list
    ;

subroutine_op_args = subroutine_op_arg ("," subroutine_op_arg)*;

subroutine_op_arg =
    qubit
    | "[" qubit_list "]"
    ;

qubit_list  = qubit (", " qubit)*;

float_list = float_literal (", " float_literal)*;

qubit =
    singular_qubit
    | register_qubit
    ;

bit_list = bit (", " bit)*;

bit = singular_bit
    | register_bit
    ;


if_stmt =
    'if' expression ':' NEWLINE INDENT compound_stmts DEDENT elif_stmt
    | 'if' expression ':' NEWLINE INDENT compound_stmts DEDENT (else_stmt)?;
elif_stmt =
    'elif' expression ':' NEWLINE INDENT compound_stmts DEDENT elif_stmt
    | 'elif' expression ':' NEWLINE INDENT compound_stmts DEDENT (else_stmt)?;
else_stmt =
    'else' ':' NEWLINE INDENT compound_stmts DEDENT;

# The expressions below are from https://docs.python.org/3/reference/grammar.html
# Parts have been commented out / removed / modified to remove unnecessary complexity

# EXPRESSIONS
# -----------

expression =
    disjunction;

disjunction =
    conjunction ('or' conjunction )+
    | conjunction;

conjunction =
    inversion ('and' inversion )+
    | inversion;

inversion =
    comparison;

# Comparison operators
# --------------------

comparison =
    bitwise_or compare_op_bitwise_or_pair;

compare_op_bitwise_or_pair =
    eq_bitwise_or
    | noteq_bitwise_or
    | lte_bitwise_or
    | lt_bitwise_or
    | gte_bitwise_or
    | gt_bitwise_or;

eq_bitwise_or: '==' bitwise_or;
noteq_bitwise_or: '!=' bitwise_or;
lte_bitwise_or: '<=' bitwise_or;
lt_bitwise_or: '<' bitwise_or ;
gte_bitwise_or: '>=' bitwise_or;
gt_bitwise_or: '>' bitwise_or ;


# Bitwise operators
# -----------------

bitwise_or:
    # | bitwise_or '|' bitwise_xor
    bitwise_xor;

bitwise_xor:
    # | bitwise_xor '^' bitwise_and
    bitwise_and;

bitwise_and:
    # | bitwise_and '&' shift_expr
    shift_expr;

shift_expr:
    # | shift_expr '<<' primary
    # | shift_expr '>>' primary
    primary;


# Primary elements
# ----------------

primary:
    atom;

atom: NUMBER;
