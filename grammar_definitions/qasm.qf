# qasm.qf

EXTENSION = ".qasm";
MAX_NUM_QUBITS = 10;

EXTERNAL {
    singular_qubit_def = qubit_def_name;

    singular_bit_def = bit_def_name;

    qubit_defs = qubit_def (COMMA qubit_def)*;

    bit_defs = bit_def (COMMA bit_def)*;

    qubit_def = singular_qubit_def;

    bit_def = singular_bit_def;
}

register_qubit_def = "qreg " qubit_def_name "[" qubit_def_size "];";

register_bit_def = "creg " bit_def_name "[" bit_def_size "];";

qubit_defs = (qubit_def NEWLINE)+;

bit_defs = (bit_def NEWLINE)+;

qubit_def = register_qubit_def;

bit_def = register_bit_def;


# 2. QASM STRUCTURE
# -----------------
header = 'OPENQASM 2.0;' NEWLINE 'include "qelib1.inc";';

program = header NEWLINE NEWLINE registers NEWLINE subroutine_defs NEWLINE body;

registers = qubit_defs NEWLINE bit_defs;

subroutine_defs = (subroutine_circuit NEWLINE)*;

body = compound_stmts;

subroutine_body = compound_stmts;

compound_stmts = (compound_stmt NEWLINE)+;

compound_stmt = qubit_op;

subroutine_circuit = "gate " circuit_name " " EXTERNAL::qubit_defs " { " NEWLINE subroutine_body "}";

subroutine_op = subroutine " " qubit_list

# 3. GATES
# --------
# QASM syntax: name(params) arg1, arg2;

singular_qubit = qubit_name;

register_qubit = qubit_name "[" qubit_index "]";


singular_bit = bit_name;

register_bit = bit_name "[" bit_index "]";


gate_op_args = "(" float_list ") " qubit_list | " " qubit_list;

gate_op = gate_name gate_op_args ";";

gate_name = h | x | y | z | s | sdg | t | tdg | cx | cy | cz | ch |
    ccx | rx | ry | rz | u1 | u2 | u3;

h = "h";
x = "x";
y = "y";
z = "z";
s = "s";
sdg = "sdg";
t = "t";
tdg = "tdg";
cx = "cx";
cy = "cy";
cz = "cz";
ch = "ch";
ccx = "ccx";
rx = "rx";
ry = "ry";
rz = "rz";
u1 = "u1";
u2 = "u2";
u3 = "u3";


# NOTE: QASM 2.0 does not support if/else blocks in the standard body easily
# without opaque definitions, so we rely on flattened gate lists here.
