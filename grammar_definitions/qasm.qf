# qasm.qf

EXTENSION = ".qasm";
MAX_REG_SIZE = 1;

EXTERNAL {
    singular_qubit_def = NAME;

    singular_bit_def = NAME;

    qubit_defs = qubit_def (COMMA qubit_def)[UNIFORM(3, 4)];

    bit_defs = bit_def (COMMA bit_def)[UNIFORM(3, 4)];

    qubit_def = singular_qubit_def;

    bit_def = singular_bit_def;
}

register_qubit_def = "qreg " NAME "[" SIZE "];";

register_bit_def = "creg " NAME "[" SIZE "];";

qubit_defs = (qubit_def NEWLINE)[UNIFORM(3, 4)];

bit_defs = (bit_def NEWLINE)[UNIFORM(3, 4)];

qubit_def = register_qubit_def;

bit_def = register_bit_def;


# 2. QASM STRUCTURE
# -----------------
header = 'OPENQASM 2.0;' NEWLINE 'include "qelib1.inc";';

program = header NEWLINE NEWLINE registers NEWLINE subroutine_defs NEWLINE body;

registers = qubit_defs NEWLINE bit_defs;

# subroutine_defs = (subroutine_circuit NEWLINE)*;

# subroutine_defs = (subroutine_circuit NEWLINE)[2];

subroutine_defs = (subroutine_circuit NEWLINE)[UNIFORM(1, 3)];

body = compound_stmts;

subroutine_body = compound_stmts;

compound_stmts = (compound_stmt NEWLINE)+;

compound_stmt = qubit_op;

subroutine_circuit = "gate " CIRCUIT_NAME " " EXTERNAL::qubit_defs " { " NEWLINE INDENT subroutine_body DEDENT "}";

subroutine_op = subroutine " " qubit_list;

# 3. GATES
# --------
# QASM syntax: name(params) arg1, arg2;

singular_qubit = NAME;

register_qubit = NAME "[" INDEX "]";

singular_bit = NAME;

register_bit = NAME "[" INDEX "]";


gate_op_args = ("(" float_list ") ")[NUM_FLOATS >= 1] qubit_list;

gate_op = gate_name " " gate_op_args ";";

gate_name = h | x | y | z | s | sdg | t | tdg | cx | cy | cz | ch |
    ccx | rx | ry | rz | u1 | u2 | u3;

h = "h";
x = "x";
y = "y";
z = "z";
s = "s";
sdg = "sdg";
t = "t";
tdg = "tdg";
cx = "cx";
cy = "cy";
cz = "cz";
ch = "ch";
ccx = "ccx";
rx = "rx";
ry = "ry";
rz = "rz";
u1 = "u1";
u2 = "u2";
u3 = "u3";


# NOTE: QASM 2.0 does not support if/else blocks in the standard body easily
# without opaque definitions, so we rely on flattened gate lists here.
