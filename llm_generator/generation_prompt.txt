**Role:** You are an advanced Guppy code generator.

**Goal:** Your task is to generate complex, syntactically valid Guppy code. The code is for a **fuzzing campaign**, so its primary purpose is to test the Guppy compiler coverage.

**Key Directives:**

1. **Strictly Deterministic:** The generated code must be **100% deterministic**. No `random` imports. All values (angles, loop ranges, conditions) must be hardcoded constants or derived deterministically.
    
2. **Function Composition & Complexity:**
    
	- Generate multiple functions (e.g., `func_A`, `func_B`).
        
    - **Inter-function Calls:** Functions should invoke _each other_ (e.g., `func_A` calls `func_B`) to increase complexity. Ensure argument types and counts match perfectly.
        
    - **Decorator Rule:**
        
        - Use **`@guppy`** if the function contains conditional branching (e.g., `if-else`, `while`, `for`).
            
        - Use **`@guppy.comptime`** if the function is purely linear (no control flow).
3. **Mandatory Main Function:**
	
	- **Logic:** It must instantiate necessary initial qubits/variables, invoke the helper functions, and **destructively measure** all qubits at the end to prevent leakage.
	    
	- **No Return:** Generate a final `main` function that accepts **zero arguments** and returns **`None`**.
        
4. **Compilation Command:** At the very end of the code, strictly invoke `.compile()` on the main function (e.g., `main.compile()`).
5. **Measurement Rules (Strict):**
    
    - You must use the 3 specific variations of measurement defined in the specifications below (`measure`, `measure_array`, `measure_and_reset`).
        
    - **Crucial:** `measure(qreg[i])` is **ILLEGAL**. You cannot use the standard `measure` on elements of an array.
        
6. **Enforce Linearity:**
    
    - **Borrowed:** Qubits passed as arguments must _not_ be measured inside that function (unless passed to another function that returns them, but simplest is to not measure borrowed).
        
    - **Owned:** Must be consumed by `measure` or `measure_array` before the scope ends. `measure_and_reset` does **not** count as consuming the qubit (it keeps it alive).
        
7. **Output Format:** Provide **only** the raw Guppy code. Do not add explanations, comments, or apologies.
---

### Guppy Language Specification (Strict Rules)

**1. Imports**
```Python
from guppylang.decorator import guppy 
from guppylang.std.angles import angle 
from guppylang.std.builtins import array, owned, py, comptime, result, owned, barrier
from guppylang.std.quantum import *
from guppylang.std.qsystem import *
```
**2. Decorator & Control Flow Rules**

- **Conditional Logic:** If you use `if`, `else`, or loops, the function **must** be decorated with `@guppy`.
    
- **Linear Logic:** If the function has no control flow, use `@guppy.comptime`.
**3. Function Definitions** All quantum functions must use either the `@guppy` or `@guppy.comptime` decorator. Functions can take qubits, qubit arrays, or classical types as arguments.
```Python
@guppy.comptime
def random_circuit_name(qubit1: qubit, qreg2: array[qubit, 2], classical_val: int) -> None: 
	# ... function body ...
```
**4. Qubit Definitions (Inside a function)** These are "owned" qubits and **must be measured**.
```Python
# Defining single qubits:
qubit1 = qubit()

# Defining qubit registers (use hardcoded integers):
num_qubits = 4 
qreg0 = array(qubit() for _ in range(num_qubits))
```
**5. Measurement & Cleanup Rules (Use all 3)**

- **`measure(q)`**:
    
    - **Target:** Only accepts a standalone `qubit` variable.
        
    - **Effect:** Destructive (consumes the qubit).
        
    - **Restriction:** **NEVER** use on array elements (e.g., `measure(q_reg[0])` is forbidden).
        
- **`measure_array(q_reg)`**:
    
    - **Target:** Accepts an entire `array[qubit, N]`.
        
    - **Effect:** Destructive (consumes the _entire_ register).
        
    - **Usage:** Use this to clean up registers at the end of a function.
        
- **`measure_and_reset(q)`**:
    
    - **Target:** Accepts standalone `qubit` OR array elements `q_reg[i]`.
        
    - **Effect:** **Non-destructive**. Measures, records result, and resets qubit to ∣0⟩.
        
    - **Note:** Because it is non-destructive, the qubit is _still alive_ after this call. You must still eventually use `measure` or `measure_array` to consume it before the function ends.
**6. Gate Syntax** You must use a wide variety of gates from the lists below.

**A. 1-Qubit Gates (No Angle)**

- **Gates:** `x`, `y`, `z`, `h`, `s`, `t`, `sdg`, `tdg`, `v`, `vdg`
    
- **Example Syntax:**
- ```Python x(qubit1)
  h(qreg0[0])
  s(qubit1)
  tdg(qreg0[1])
```

**B. 1-Qubit Gates (With Angle)**

- **Gates:** `rx`, `ry`, `rz`
    
- **Example Syntax:**
- ```Python
  rx(qubit1, angle(0.123))
  ry(qreg0[1], angle(pi / 3))
  rz(qubit1, angle(1.98))
  ```
  
**C. 2-Qubit Gates (No Angle)**

- **Gates:** `cx`, `ch`, `cy`, `cz`
    
- **Example Syntax:**
- ```Python 
  cx(qubit1, qreg0[0])  # CNOT
  ch(qreg0[1], qreg0[2]) # Controlled-Hadamard
  cy(qreg[2], qubit3)  # Controlled Y gate
```

**D. 2-Qubit Gate (With Angle)**

- **Gate:** `crz`
    
- **Rule:** Qubit arguments come first, the `angle` argument must come at the end.
    
- **Example Syntax:**
- ```Python
  crz(qubit1, qreg0[0], angle(1.1))
  crz(qreg0[1], qreg0[2], angle(0.45 * pi))
```

**E. 3-Qubit Gate**

- **Gate:** `toffoli`
    
- **Example Syntax:**
- ```Python
  toffoli(qubit1, qreg0[0], qreg0[2])
```

**7. Linearity and Control Flow (Example)** Combine all rules. Notice how `q_in` (borrowed) is not measured, but `q_local` (owned) is. All control flow is deterministic, depending on the function argument `control_val`.
```Python
@guppy.comptime
def fuzzer_example(q_in: qubit, control_val: float) -> int:
    
    # Define local, "owned" qubits
    q_local = qubit()
    q_reg = array(qubit() for _ in range(3)) # Hardcoded size
    
    # Classical control flow based on deterministic argument
    if control_val > 0.5:
        # Apply gates to borrowed qubit
        x(q_in)
        h(q_in)
    else:
        # Apply gates to owned qubits
        cnot(q_local, q_reg[0])
        for i in range(3): # Hardcoded loop
            # Angle is deterministic (based on arg and loop counter)
            rz(q_reg[i], angle(control_val * pi * float(i)))
    
    barrier(q_in, q_local)
    
    # Consume "owned" qubits by measuring them
    m_local = measure(q_local)
    measure_array(q_reg) # Must measure all in the register
        
    # Return a classical value
    return m_local
```
**8. Structure Example (Inter-function calls & Main)**

```Python
@guppy.comptime
def sub_routine(q: qubit) -> None:
    # Standard gates
    v(q)
    # Non-destructive measure (acts like a gate, q is still alive)
    res = measure_and_reset(q) 
    x(q) # Valid because q was reset, not consumed

@guppy
def complex_logic(q_in: qubit, q_reg: array[qubit, 2]) -> None:
    sub_routine(q_in)
    
    if 1 < 2: 
        cx(q_in, q_reg[0])
        # Valid: measure_and_reset allows array indexing
        _ = measure_and_reset(q_reg[0]) 
    else:
        vdg(q_in)

@guppy
def main() -> None:
    # 1. Generate Inputs/Qubits
    q1 = qubit()
    q_reg = array(qubit() for _ in range(2))
    
    # 2. Invoke Functions
    complex_logic(q1, q_reg)
    
    # 3. Destructive Cleanup
    
    # INVALID: measure(q_reg[0]) <- DO NOT DO THIS
    
    # VALID: Measure entire array at once
    measure_array(q_reg)
    
    # VALID: Measure standalone qubit
    _ = measure(q1)

# 5. MANDATORY Compilation
main.compile()
```
**Your Task:** Generate a new, random-looking, **fully deterministic** block of Guppy code. It must include:

1. At least 2 helper functions (invoking each other where possible).
	
2. Usage of `measure_and_reset` for mid-circuit measurement (on both standalone and register qubits).
	
3. Use `measure_array` for registers and `measure` for standalone qubits. Never use `measure` on a register element.
    
4. Correct decorators (`@guppy` vs `@guppy.comptime`) based on control flow.
    
5. A `main` function that takes no arguments, sets up qubits, calls the helpers, cleans up, and returns `None`.
    
6. `main.compile()` at the end.